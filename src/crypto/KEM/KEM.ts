// https://www.rfc-editor.org/rfc/rfc9180.html#section-4
import { Buffer } from 'node:buffer';
import { KDF } from '../KDF/KDF';

export enum KEMAlgorithm {
	P256HKDFSHA256  = 0x0010
}

export type KEMKeyPair = [ KEMPrivateKey, KEMPublicKey ];
export type SerializedKEMKey = Buffer;
export type SerializedKEMKeyPair = [ SerializedKEMKey, SerializedKEMKey ];

export abstract class KEM {
	public abstract readonly id: KEMAlgorithm;

	/**
	 * The length in bytes of a KEM shared secret produced by this KEM. (Nsecret)
	 */
	public abstract readonly secretLength: number;

	/**
	 * The length in bytes of an encapsulated key produced by this KEM. (Nenc)
	 */
	public abstract readonly encLength: number;

	/**
	 * The length in bytes of an encoded public key for this KEM. (Npk)
	 */
	public abstract readonly pkLength: number;

	/**
	 * The length in bytes of an encoded private key for this KEM. (Nsk)
	 */
	public abstract readonly skLength: number;

	/**
	 * Associated KDF
	 */
	public abstract readonly kdf: KDF;

	/**
	 * Randomized algorithm to generate a key pair (skX, pkX).
	 */
	public abstract generateKeyPair(): KEMKeyPair;

	/**
	 * Deterministic algorithm to derive a key pair (skX, pkX) from the byte 
	 * array ikm, where ikm SHOULD have at least Nsk bytes of entropy.
	 * @param ikm Byte array.
	 * 
	 * @throws {@link DeriveKeyPairError}
	 */
	public abstract deriveKeyPair(ikm: Buffer): KEMKeyPair;

	/**
	 * Produce a byte array of length Npk encoding the public key pkX.
	 * @param pkX Public key.
	 */
	public abstract serializePublicKey(pkX: KEMPublicKey): SerializedKEMKey;

	/**
	 * Parse a byte array of length Npk to recover a public key. 
	 * @param pkXm Serialized public key.
	 * 
	 * @throws {@link DeserializeError} upon pkXm deserialization failure.
	 */
	public abstract deserializePublicKey(pkXm: Buffer): KEMPublicKey;

	/**
	 * Produce a byte string of length Nsk encoding the private key skX.
	 * @param skX Private key.
	 */
	public abstract serializePrivateKey?(skX: KEMPrivateKey): SerializedKEMKey;

	/**
	 * Parse a byte string of length Nsk to recover a private key.
	 * @param skXm Serialized private key.
	 * 
	 * @throws {@link DeserializeError} upon skXm deserialization failure.
	 */
	public abstract deserializePrivateKey?(skXm: Buffer): KEMPrivateKey;
}

export abstract class KEMPublicKey {
	constructor (
		public readonly kem: KEM,
		public readonly raw: Buffer
	) {
		if (raw.length === this.kem.pkLength){
			this.raw = raw;
		} else {
			const buf = Buffer.alloc(this.kem.pkLength);
			raw.copy(buf);
			this.raw = buf;
		}
	}

	/**
	 * Randomized algorithm to generate an ephemeral, fixed-length symmetric key 
	 * (the KEM shared secret) and a fixed-length encapsulation of that key that 
	 * can be decapsulated by the holder of the private key corresponding to pkR. 
	 * 
	 * @throws {@link EncapError} on encapsulation failure.
	 */
	public abstract encap(): SerializedKEMKeyPair;

	/**
	 * Same as {@link KEMPublicKey.encap}, and the outputs encode an assurance that 
	 * the KEM shared secret was generated by the holder of the private key skS.
	 * @param skS Private key.
	 * 
	 * @throws {@link EncapError} on encapsulation failure.
	 */
	public abstract authEncap?(skS: KEMPrivateKey): SerializedKEMKeyPair;
}

export abstract class KEMPrivateKey {
	constructor (
		public readonly kem: KEM,
		public readonly raw: Buffer
	) {
		if (raw.length === this.kem.pkLength){
			this.raw = raw;
		} else {
			const buf = Buffer.alloc(this.kem.pkLength);
			raw.copy(buf);
			this.raw = buf;
		}
	}

	/**
	 * Deterministic algorithm using the private key skR to recover the ephemeral 
	 * symmetric key (the KEM shared secret) from its encapsulated representation enc.
	 * @param enc Encapsulated representation.
	 * 
	 * @throws {@link DecapError} on decapsulation failure.
	 */
	public abstract decap(enc: SerializedKEMKey): SerializedKEMKey;

	/**
	 * Same as {@link KEMPrivateKey.decap}, and the recipient is assured that the 
	 * KEM shared secret was generated by the holder of the private key skS.
	 * @param enc Encapsulated representation.
	 * @param pkS Public key.
	 * 
	 * @throws {@link DecapError} on decapsulation failure.
	 */
	public abstract authDecap?(enc: SerializedKEMKey, pkS: KEMPublicKey): SerializedKEMKey;
}

export class ValidationError extends Error {
	constructor(cause: Error) {
		super('KEM input/output validation failure.', { cause });
		this.name = 'ValidationError';
	}
}

export class DeserializeError extends Error {
	constructor(cause: Error) {
		super('Failed to deserialize public key.', { cause });
		this.name = 'DeserializeError';
	}
}

export class DeriveKeyPairError extends Error {
	constructor(cause: Error) {
		super('Failed to derive key pair.', { cause });
		this.name = 'DeriveKeyPairError';
	}
}

export class EncapError extends Error {
	constructor(cause: Error) {
		super('Failed to encapsulate public key.', { cause });
		this.name = 'EncapError';
	}
}

export class DecapError extends Error {
	constructor(cause: Error) {
		super('Failed to decapsulate private key.', { cause });
		this.name = 'DecapError';
	}
}
